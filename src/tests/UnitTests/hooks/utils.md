## hooks/utils ユニットテスト設計

このドキュメントは `src/hooks/utils` 配下の汎用カスタムフックに対するユニットテスト項目をまとめたものです。
実装は Vitest と React Testing Library の `renderHook` を用い、テストファイルは `src/tests/UnitTests/hooks/utils` 配下に作成します。

---

## 1. `useGotoTopPage`

前提:  
Next.jsの `useRouter` を使用してモーダルを閉じ、トップページに遷移する関数を返すフック。  
`useRouter` と `closeModal` ユーティリティ関数をモック化する。

### 1-1. 基本動作の検証

- **返り値の型確認**
  - `useGotoTopPage()` を実行すると、関数が返されること
  - 返された関数は `setIsOpen` を引数に取ること
- **useRouterの呼び出し**
  - フックがレンダリングされると、`useRouter()` が呼ばれること
  - `useRouter()` から返される `router` オブジェクトが正しく取得されること

### 1-2. 返された関数の動作検証

- **`closeModal` の呼び出し**
  - 返された関数を `setIsOpen` モック関数と共に実行すると、`closeModal(setIsOpen)` が呼ばれること
  - `closeModal` に渡される引数が、実行時に渡した `setIsOpen` と同じであること
- **`router.push` の呼び出し**
  - 返された関数を実行すると、`router.push("/")` が呼ばれること
  - `push` に渡される引数が `"/"` であること
- **呼び出し順序の確認**
  - `closeModal` が `router.push` よりも先に呼ばれること
- **複数回の実行**
  - 返された関数を複数回実行しても、毎回正しく `closeModal` と `router.push` が呼ばれること

### 1-3. エッジケース

- **再レンダリング時の動作**
  - フックが再レンダリングされても、新しい関数が返されること
  - 返された各関数は独立して動作すること
- **異なる `setIsOpen` 関数での実行**
  - 異なる `setIsOpen` モック関数で実行した場合、それぞれ正しい関数が `closeModal` に渡されること

---

## 2. `useUpdateEffect`

前提:  
React の `useEffect` をラップし、初回レンダリング時の実行をスキップするカスタムフック。  
内部で `useRef` と `useEffect` を使用している。

### 2-1. 初回レンダリング時の動作

- **初回レンダリング時のスキップ**
  - フックを初回レンダリング時に呼び出した場合、エフェクト関数が実行されないこと
  - 依存配列が変更されていない初回では、エフェクトがスキップされること
- **Refの初期化**
  - 初回レンダリング時に内部の `isFirst` ref が `true` から `false` に変更されること

### 2-2. 依存配列変更時の動作

- **依存配列の変更時の実行**
  - 依存配列のいずれかの値が変更されると、エフェクト関数が実行されること
  - 複数回の変更に対して、毎回エフェクト関数が実行されること
- **エフェクト関数の引数**
  - エフェクト関数に引数が渡されないこと（通常の `useEffect` と同様）
- **エフェクト関数の呼び出し回数**
  - 初回レンダリングでは0回、依存配列変更ごとに1回ずつ増加すること

### 2-3. クリーンアップ関数の動作

- **クリーンアップ関数の返却**
  - エフェクト関数がクリーンアップ関数を返した場合、次の実行前に呼ばれること
  - アンマウント時にクリーンアップ関数が呼ばれること
- **クリーンアップ関数の実行タイミング**
  - 初回レンダリング時はクリーンアップ関数が呼ばれないこと（エフェクトが実行されないため）
  - 2回目以降の依存配列変更時に、前回のクリーンアップが実行されてから新しいエフェクトが実行されること

### 2-4. 依存配列のバリエーション

- **単一の依存値**
  - 依存配列に1つの値が含まれる場合、その値の変更でエフェクトが実行されること
  - その値が変更されない場合、エフェクトが実行されないこと
- **複数の依存値**
  - 依存配列に複数の値が含まれる場合、いずれかの値が変更されるとエフェクトが実行されること
  - すべての値が変更されない場合、エフェクトが実行されないこと
- **プリミティブ型の依存値**
  - number, string, boolean などのプリミティブ型が依存配列に含まれる場合、値の比較が正しく行われること
- **オブジェクト・配列の依存値**
  - オブジェクトや配列が依存配列に含まれる場合、参照の変更で正しくエフェクトが実行されること

### 2-5. エッジケース

- **空の依存配列**
  - 依存配列が空配列 `[]` の場合、初回レンダリング後は一度も実行されないこと
- **依存配列なし（undefined）**
  - 依存配列が渡されない場合のエラーハンドリング（TypeScript型定義で防止されるべき）
- **同じ値への更新**
  - 依存値が同じ値に更新された場合（例: 1 → 1）、エフェクトが実行されないこと
- **連続した変更**
  - 依存値が短時間に連続して変更された場合、各変更ごとにエフェクトが実行されること

### 2-6. 実装の検証

- **useRef の使用確認**
  - 内部で `useRef` が使用され、初回判定フラグが保持されていること
  - このフラグがレンダリング間で保持されること
- **useEffect の使用確認**
  - 内部で `useEffect` が使用され、依存配列が正しく渡されていること
- **依存配列の展開**
  - 渡された依存配列が正しく `useEffect` の依存配列として展開されていること（スプレッド構文 `[...deps]`）

---

## 3. テスト実装方針メモ

- テストランナー: Vitest（`package.json` の `test` スクリプトを使用）
- テストライブラリ: React Testing Library の `renderHook`, `act`
- テストディレクトリ: `src/tests/UnitTests/hooks/utils`
- 各フックごとに以下のような構成を想定
  - `utils/useGotoTopPage.test.ts`
  - `utils/useUpdateEffect.test.ts`
- **モック化が必要なもの（useGotoTopPage）**
  - `next/navigation` の `useRouter`
  - `@/utils/closeModal` 関数
- **モック化が必要なもの（useUpdateEffect）**
  - 基本的にモック不要（React標準フックのみ使用）
  - エフェクト関数とクリーンアップ関数は `vi.fn()` でモック関数として渡す
- **テスト戦略**
  - `useGotoTopPage`: モックの呼び出し順序と引数を検証
  - `useUpdateEffect`: `renderHook` の `rerender` 機能を使用して依存配列の変更をシミュレート
  - `act` を使用して状態更新を適切にラップする
