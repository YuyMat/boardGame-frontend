# useEffect コードレビュー（厳密評価）

対象: `frontend` 内の `useEffect(` 使用箇所（12ファイル / 18箇所）

## 評価基準
1. useEffect には必ず「副作用（side effect）」のみが書かれているか  
2. 依存配列（deps）が正しく設定されているか  
   - 過不足がないか  
   - 不必要な re-render を起こしていないか  
3. cleanup（後処理）が必要な場合に return で正しく実装されているか  
4. 不要な setState による無限ループを引き起こしていないか  
5. 初回のみ実行・値の変化時のみ実行など、意図が明確に反映されているか  
6. useEffect に複数の目的が混ざっていないか（副作用の分離）  
7. React 18 の StrictMode での2回実行を考慮しても問題のない設計か  
8. 非同期処理（fetch など）の取り扱いが適切か（race condition 回避等）

---

## 1. useEffect ごとの評価（良い点・悪い点）

### (1) `frontend/src/app/(games)/reversi/page.tsx`（L69-96）
- **良い点**
  - 盤面変化に応じたハイライト更新・パス/終局処理という「副作用（状態更新）」をまとめて実行できている。
  - 無限ループは起こしにくい（パス時のみ `currentRole` を1回進める設計）。
- **悪い点**
  - `computeHighlights` を外から参照しているのに deps に入っておらず、`exhaustive-deps` 的には不合格（関数を effect 内に移すか `useCallback` 化が必要）。
  - `blackCount/whiteCount` を **ref + useEffect で更新**していて、表示値が「レンダリングと同期しない」設計（ref 更新は再描画を起こさないため、別の state 更新に依存して追従している状態）。
  - 「派生データ（ハイライト/石数）」と「ゲーム遷移（パス/終局）」が同一 effect に混在（目的分離の観点で改善余地）。
- **結論**: **要改善**（deps と派生データの扱いがベストプラクティスから外れる）

### (2) `frontend/src/app/(games)/memory/page.tsx`（L29-53: 判定処理）
- **良い点**
  - タイマーの cleanup を返していて適切（timeout 二重発火を防げる）。
  - `cardStateBoard` 変化をトリガーに判定を走らせる意図は明確。
- **悪い点**
  - effect 内で `cardBoard` / `currentRole` も使っているのに deps が `[cardStateBoard]` のみ。動作意図として成立している可能性はあるが、「依存配列が正しい」とは言い切れない（将来の変更で破綻しやすい）。
  - 「ペア判定」と「終了判定 + 終了演出タイマー」が同一 effect に混在（目的分離の観点で改善余地）。
- **結論**: **軽微に要改善**（deps と責務分離）

### (3) `frontend/src/app/(games)/memory/page.tsx`（L56-59: カード初期化）
- **良い点**
  - `settings.cards` の変化にのみ反応して初期化する意図が明確。
  - deps も過不足が少ない。
- **悪い点**
  - 派生 state を effect で同期している（許容されるが、設計次第で `key` によるリマウント等の方が安全なこともある）。
- **結論**: **問題なし（改善余地は小）**

### (4) `frontend/src/hooks/utils/useRoomInitializer.ts`（L16-43）
- **良い点**
  - 非同期処理の結果で `router.replace` / state 更新を行うという副作用が明確。
  - cleanup で `isMounted` を落として「アンマウント後の更新」を抑制している。
- **悪い点**
  - **React 18 StrictMode の2回実行で `createRoom()` が2回走り得る**（1回目は遷移しなくても “部屋だけ作られる” 可能性が高い）。基準(7)に抵触。
  - `isMounted` は「更新抑制」にはなるが **通信の中断にならない**（race / 無駄リクエストの観点で基準(8)が弱い）。
  - `checkHealth` が throw した場合のハンドリングが見えない（未捕捉 promise になり得る）。
- **結論**: **要改善（重要）**

### (5) `frontend/src/components/Utils/GameRule.tsx`（L26-28）
- **良い点**
  - マウント後にのみ Modal を出す目的が明確。
  - deps `[]` も正しい。
  - StrictMode でも実害が出にくい。
- **悪い点**
  - 「mounted フラグのためだけの effect」はパターンとしては許容だが、増えると構造が散らかりやすい（軽微）。
- **結論**: **問題なし**

### (6) `frontend/src/hooks/reversi/useReversiRoom.ts`（L49-94: ソケット接続・購読）
- **良い点**
  - 接続・イベント購読・タイマーを行い、cleanup で `off`/`disconnect`/`clearTimeout` をしていて良い（基準(3)を満たす）。
- **悪い点**
  - deps が `[roomId]` のみで、外部から渡る `setFirstRole` 等を含めていない（通常は安定だが、厳密には「依存配列が完全」とは言いにくい）。
  - `roomPaired` が短時間に複数回飛んだ場合、`matchStateRef` 更新が effect 経由なので一瞬だけ二重処理余地がある（小さな競合窓）。
- **結論**: **軽微に要改善**

### (7) `frontend/src/hooks/reversi/useReversiRoom.ts`（L102-104: matchStateRef 同期）
- **良い点**
  - イベントハンドラから最新 `matchState` を参照したい目的は妥当。
- **悪い点**
  - ref 同期だけの effect は「副作用」ではあるが、レンダー中に `matchStateRef.current = matchState` と代入すれば effect 不要（StrictMode/タイミングの揺れも減る）。
- **結論**: **軽微に要改善**

### (8) `frontend/src/hooks/reversi/_internal/useReversiSocketSync.ts`（L23-39: 受信購読）
- **良い点**
  - `on`/`off` の cleanup が正しい。
- **悪い点**
  - deps が `[roomId]` だが、実際の購読対象は `socketRef.current`。
  - `socketRef.current` が effect 実行時に未設定だと購読されず、以後も再実行されない設計になり得る（呼び出し順に依存する“脆さ”）。
- **結論**: **要改善**

### (9) `frontend/src/hooks/reversi/_internal/useReversiSocketSync.ts`（L42-58: 送信）
- **良い点**
  - 受信→送信のエコーを `suppressSyncRef` で抑制している点は良い。
- **悪い点（重要）**
  - deps が `[board]` のみで、`roomId/currentRole/lastPosition/matchState` を参照している。
  - **依存配列が不足**しており、特に Reversi の「パスで `currentRole` だけ変わる」ケースだと **同期漏れ**が起き得る（基準(2)(5)）。
- **結論**: **要改善（重要）**

### (10) `frontend/src/hooks/reversi/_internal/useReversiRestart.ts`（L18-37）
- **良い点**
  - `on`/`off` cleanup が正しい。
- **悪い点**
  - deps `[roomId]` だが effect 内で `roomId` を使っていない。再購読目的なら理解できるが、厳密には「必要十分」ではない。
  - `resetGameState` が不安定（毎レンダで新関数）な場合、古い関数を掴む可能性がある（deps に入れるか `useEvent`/ref 化が安全）。
- **結論**: **要改善**

### (11) `frontend/src/hooks/connect4/useConnect4Room.ts`（L47-92: ソケット接続・購読）
- **評価**: (6) とほぼ同じ。
- **結論**: **軽微に要改善**（cleanup は良いが deps 完全性・競合窓の観点で改善余地）

### (12) `frontend/src/hooks/connect4/useConnect4Room.ts`（L95-98: setFirstRole 送信）
- **良い点**
  - `firstRole` と `roomId` を deps に入れている点は良い。
- **悪い点**
  - `socketRef.current` が未設定のタイミングで一度 return すると、以後 deps が変わらない限り送信されない（初回送信が欠落し得る）。
  - StrictMode ではマウントが2回起きるため、マウント時送信を入れる設計だと **二重送信**になり得る（基準(7)）。
- **結論**: **要改善**

### (13) `frontend/src/hooks/connect4/useConnect4Room.ts`（L100-102: matchStateRef 同期）
- **評価**: (7) と同じ。
- **結論**: **軽微に要改善**

### (14) `frontend/src/hooks/connect4/_internal/useConnect4SocketSync.ts`（L23-39: 受信購読）
- **評価**: (8) と同じ。
- **結論**: **要改善**（socketRef.current の準備タイミングに依存）

### (15) `frontend/src/hooks/connect4/_internal/useConnect4SocketSync.ts`（L42-58: 送信）
- **評価**: (9) と同じ。
- **結論**: **要改善（重要）**（deps 不足）

### (16) `frontend/src/hooks/connect4/_internal/useConnect4Restart.ts`（L19-38）
- **評価**: (10) と同じ。
- **結論**: **要改善**

### (17) `frontend/src/components/Connect4/TemporaryWaiting.tsx`（L25-30）
- **良い点**
  - `members` の変化に追従する意図は明確。
  - 無限ループは起きない。
- **悪い点**
  - `isOpen` が **props（members）から一意に導ける派生状態**で、useEffect で同期している（基準(1)(6)の観点で非推奨。不要な追加レンダーも発生）。
- **結論**: **要改善**

### (18) `frontend/src/hooks/utils/useUpdateEffect.ts`（L24-27）
- **良い点**
  - “初回だけスキップ” という目的が明確。
  - cleanup も呼び出し側 effect に委譲できる形で良い。
- **悪い点**
  - `deps` を `[...]` で展開しているのは動作上問題ないが、スタイルとしてはそのまま `deps` を渡す方が素直（軽微）。
- **結論**: **問題なし（軽微）**

---

## 2. 依存配列の適切性

- **問題なし（概ね適切）**
  - `frontend/src/components/Utils/GameRule.tsx`（`[]`）
  - `frontend/src/app/(games)/memory/page.tsx`（カード初期化: `[settings.cards]`）
  - `frontend/src/hooks/utils/useRoomInitializer.ts`（`[gamePath, router]` 自体は妥当）

- **不足/不整合がある（要修正）**
  - `frontend/src/hooks/reversi/_internal/useReversiSocketSync.ts` 送信（deps `[board]` のみ）
  - `frontend/src/hooks/connect4/_internal/useConnect4SocketSync.ts` 送信（deps `[board]` のみ）
  - `frontend/src/hooks/reversi/useReversiRoom.ts` の `useUpdateEffect` 呼び出し（`roomId` を参照するのに deps が `[firstRole]` のみ ※`useEffect` ではないが同種の依存問題）
  - `frontend/src/app/(games)/memory/page.tsx` 判定処理（意図は分かるが deps と参照値がズレている）
  - `frontend/src/hooks/reversi/_internal/useReversiRestart.ts` / `frontend/src/hooks/connect4/_internal/useConnect4Restart.ts`（callback 安定性前提になっている）
  - `frontend/src/hooks/reversi/_internal/useReversiSocketSync.ts` / `frontend/src/hooks/connect4/_internal/useConnect4SocketSync.ts` 受信（deps が `socketRef.current` の準備に追従できない構造）

---

## 3. クリーンアップの要否

- **cleanup 必須で、実装も概ね適切**
  - `frontend/src/hooks/reversi/useReversiRoom.ts`（ソケット + タイマー）
  - `frontend/src/hooks/connect4/useConnect4Room.ts`（ソケット + タイマー）
  - `frontend/src/hooks/reversi/_internal/useReversiSocketSync.ts` 受信（購読解除）
  - `frontend/src/hooks/connect4/_internal/useConnect4SocketSync.ts` 受信（購読解除）
  - `frontend/src/hooks/reversi/_internal/useReversiRestart.ts` / `frontend/src/hooks/connect4/_internal/useConnect4Restart.ts`（購読解除）
  - `frontend/src/app/(games)/memory/page.tsx` 判定処理（timeout の clear）

- **cleanup はあるが改善余地**
  - `frontend/src/hooks/utils/useRoomInitializer.ts`: `isMounted` で「更新抑止」はしているが、**通信の中断(Abort)がない**（基準(8)的には弱い）

---

## 4. 改善案（必要な場合のみ）

### Socket の送信 effect（Reversi/Connect4）: deps 不足を修正
- 例（最低限の方向性）:

```tsx
useEffect(() => {
  const socket = socketRef.current;
  if (!socket) return;

  if (suppressSyncRef.current) {
    suppressSyncRef.current = false;
    return;
  }
  if (matchState !== "playing") return;

  socket.emit("syncBoard", { roomId, board, currentRole, lastPosition });
}, [board, currentRole, lastPosition, matchState, roomId]);
```

### `useRoomInitializer` の StrictMode 二重実行対策
- クライアント `useEffect` で “作成系 API” を叩く限り、dev StrictMode で **二重作成リスクをゼロにできません**。根本解はどちらかです:
  - **（推奨）** ルーム作成を **サーバ側（Route Handler / Server Action / Server Component）で1回だけ**行い `redirect` する
  - もしくはバックエンド側で **createRoom を冪等化**（同一セッション/キーなら同じ roomId を返す）
- 併せて、`AbortController` 等でリクエスト中断可能にすると基準(8)も満たしやすいです。

### `TemporaryWaiting.tsx` の派生 state を廃止
- 仕様が「2人未満なら常に表示」で良いなら `open={members < 2}` にして `useEffect/useState` を削除（不要な再レンダーも消えます）。

### ref 同期の effect（`matchStateRef`）
- `matchStateRef.current = matchState;` をレンダー中に代入する形にすると、effect のタイミング揺れ/競合窓が減ります。

---

## 5. 総合スコア（10点満点）

**6 / 10**

- cleanup や購読解除はしっかりしている一方で、**Socket送信の deps 不足**と **`useRoomInitializer` の StrictMode 二重作成リスク**が「実害の出やすい」部類なので減点が大きいです。
